module UnfoldUtils.Internal where
-- https://github.com/tweag/rules_haskell/issues/152

import Prelude hiding ( iterate
                      , map )

-- Recall the definition of unfoldr for lists,

{-|
  >>> unfoldr (\b -> if b == 0 then Nothing else Just (b, b-1)) 10
  [10,9,8,7,6,5,4,3,2,1]
-}
unfoldr :: (s -> Maybe (a, s)) -> s -> [a]
unfoldr next x = case next x of
                   Nothing     -> []
                   Just (y, r) -> y : unfoldr next r

-- We can define an unfold function for binary trees as well:

data Tree a = Leaf a | Node (Tree a) (Tree a)
            deriving Show

unfoldTree :: (s -> Either a (s, s)) -> s -> Tree a
unfoldTree next x = case next x of
                      Left  y      -> Leaf y
                      Right (l, r) -> Node (unfoldTree next l) (unfoldTree next r)


{-| The call 'iterate' f x generates the infinite list [x, f x, f (f x), ...].
-}
iterate :: (a -> a) -> a -> [a]
iterate f = unfoldr (\x -> Just (x, f x))


{-|
  Prove using induction and equational reasoning that the version of map 
  you defined using unfoldr coincides with the definition of map by recursion.

  The first case is trivial
  >map f [] = [] 

  Regarding the other cases, the same definition here uses recursion.
  so here I apply function f to the first element of the list, x
  and unfoldr calls the function again on xs, so also the second element
  gets f applied to, until the list of elements is exhausted. 
  when that happens, nothing gets passed to unfoldr, so the list will
  terminate.

-}
map :: (a -> b) -> [a] -> [b]
map f = unfoldr next
  where
    next [] = Nothing
    next (x : xs) = Just(f x, xs)


{-| 'balanced' generates a balanced binary tree of the given height

  We define the size of a binary tree as the number of internal nodes.

  size (Leaf _)   = 0
  size (Node l r) = 1 + size l + size r

  What is the size of a balanced tree as generated by balanced? 
  Prove your result using induction and equational reasoning.

  n   | size
  ----+-----
  0   | 0
  1   | 1   <- it's just a top-level Node
  2   | 3   <- from the one node, two children nodes were generated
  3   | 7   <- from the new two nodes, four children were generated

  and so on.. so:
  size(0) = 0
  size(1) = 1
  size(n) = 2*(size(n-1)-size(n-2)) + size(n-1)

-}
balanced :: Int -> Tree ()
balanced n = unfoldTree (\x -> if x < n then Right (x + 1, x + 1) else Left ()) 0


{-| 'sized' generates any tree with the given number of nodes.
  Each leaf in the returned tree should have a unique label.
  EDIT: it's not working
-}
-- sized :: Int -> Tree Int
-- sized n = unfoldTree sizedRec 0
--   where
--     sizedRec :: Int -> Either Int (Int, Int)
--     sizedRec x 
--           | x < n - 2 = Right (x + 2, x + 3)
--           -- | x == n - 2 = Right (x + 1, ())
--           | otherwise = Left (x + 1)
